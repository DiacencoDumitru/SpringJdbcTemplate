#### Решим проблемы JDBC API с помощью `JdbcTemplate`
* Spring `JdbcTemplate` на ступень выше чем JDBC API. 
* Эта технология `JdbcTemplate` является тонкой обёрткой вокруг JDBC API и облегчает нам работу с БД.
* Теперь когда мы создадим метод index() он будет вместо 20 строк JDBC API занимать 1 строку JdbcTemplate. (используя более высокий уровень абстракции, нам удается сокращать код, избегать дублирования кода и вообще сам код становится чище) 

#### Проблемы JDBC API
1. **Много лишнего кода** (Connection, Statement, ResultSet)
2. **Дублирование кода** (пример: метод index(), show() из нашего DAO мы видем то что у нас один и тот же код)
3. Везде есть **неинформативный SQLException**, который надо везде обрабатывать (потому-что он выбрасывается по любому поводу: connection, table, row)

#### Приложение:
* Перепишем весь DAO на Jdbc Template
* SpringConfig, создаём бин DataSource (что-бы он знал к какой БД подключатся)
* PersonMapper который реализует RowMapper это такой объект который отображает строки в таблице в нашей сущности, то-есть каждую строку полученную в результате этого запроса из нашей таблицы Person он отобразит в объект класса Person (@Override mapRow)
* Мы можем использовать готовый RowMapper который уже есть в библиотеке Spring Jdbc (мы можем не исползовать наш собственный Mapper а использовать BeanPropertyRowMapper для указания того класса, объекта которого будет переводиться перевод строк из нашей таблице)

#### Объяснение:
`Зачем используем new Object[]{id} ?` для show() метода из DAO 
создает массив объектов, содержащий значение переменной id. Этот массив передается JdbcTemplate, который подставляет его значение в позицию `?` в **SQL-запросе**. В данном случае:
```sql
SELECT * FROM Person WHERE id=5
```
